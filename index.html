
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>搜不狗</title>
  <meta name="author" content="Allen Shi">

  
  <meta name="description" content="比较排序算法 比较排序如其名，需要通过比较两个元素的大小来确定他们的前后序列。 性能限制和优势 比较排序有很多性能上的根本限制。在最差情况下，任何一种比较排序至少需要O(nlogn)比较操作.这是比较操作所获的信息有限所导致的，或者说是全序集的模糊代数结构所导致的。从这个意义上讲，归并排序， &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://www.sobugou.com">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="搜不狗" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">搜不狗</a></h1>
  
    <h2>记录学习工作点滴</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search?q=site%3Asobugou.com" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:www.sobugou.com" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Index</a></li>
  <li><a href="/blog/archives">Blog</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/09/02/chang-jian-sortingsuan-fa-zong-jie/">常见排序算法总结</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-09-02T11:00:43+02:00'><span class='date'><span class='date-month'>Sep</span> <span class='date-day'>2</span><span class='date-suffix'>nd</span>, <span class='date-year'>2015</span></span> <span class='time'>11:00 am</span></time>
        
           | <a href="/blog/2015/09/02/chang-jian-sortingsuan-fa-zong-jie/#disqus_thread"
             data-disqus-identifier="http://www.sobugou.com/blog/2015/09/02/chang-jian-sortingsuan-fa-zong-jie/">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h2>比较排序算法</h2>

<p>比较排序如其名，需要通过比较两个元素的大小来确定他们的前后序列。</p>

<p><img src="/images/2015-09/comparisonSorts.jpg" alt="Comparison Sorting" /></p>

<ul>
<li><strong>性能限制和优势</strong></li>
</ul>


<p>比较排序有很多性能上的根本限制。在最差情况下，<strong>任何一种比较排序至少需要O(nlogn)比较操作</strong>.这是比较操作所获的信息有限所导致的，或者说是全序集的模糊代数结构所导致的。从这个意义上讲，归并排序，堆排序在他们必须比较的次数上是渐进最优的。 因此比较排序的最好情况为nlogn的复杂度。</p>

<p>不过，<strong>比较排序在控制比较函数方面有显著优势</strong>，因此比较排序能对各种数据类型进行排序，并且可以很好地控制一个序列如何被排序。例如，如果倒置比较函数的输出结果可以让排序结果倒置。或者可以构建一个按字典顺序排序的比较函数，这样排序的结果就是按字典顺序的。</p>

<p>比较排序可以更好地适应复杂顺序，例如浮点数。并且，一旦比较函数完成，任何比较算法都可以不经修改地使用；而<strong>非比较排序对数据类型的要求更严格。</strong> 这种灵活性和上述比较排序在现代计算机的执行效率一起导致了比较排序被更多地应用在了大多数实际工作中。</p>

<h3>原始输入数据情况：</h3>

<ul>
<li>平均情况：Random</li>
</ul>


<blockquote><p>A random initial order is often used to evaluate sorting algorithms in order to elucidate the &ldquo;typical&rdquo; case</p></blockquote>

<ul>
<li>最好情况 Sorting nearly sorted</li>
</ul>


<blockquote><p>It is quite common in practice. Some observations:</p>

<p>Insertion sort is the clear winner on this initial condition.
Bubble sort is fast, but insertion sort has lower overhead.
Shell sort is fast because it is based on insertion sort.
Merge sort, heap sort, and quick sort do not adapt to nearly sorted data.</p></blockquote>

<ul>
<li>最坏情况 Reversed Initial Order</li>
</ul>


<blockquote><p>Sorting an array that is initially in reverse sorted order is an interesting case because it is common in practice and it brings out worse-case behavior for insertion sort, bubble sort, and shell sort.</p></blockquote>

<h3>冒泡排序</h3>

<ul>
<li>性能分析</li>
</ul>


<p>时间复杂度O(n<sup>2</sup>), 空间复杂度O(1)， 稳定，因为存在两两比较，不存在跳跃。
最好是O(n), 最差，平均都是O(n<sup>2</sup>)</p>

<ul>
<li>步骤</li>
</ul>


<p>1 比较相邻的元素。如果第一个比第二个大，就交换他们两个。</p>

<p>2 对第0个到第n-1个数据做同样的工作。这时，最大的数就“浮”到了数组最后的位置上。</p>

<p>3 针对所有的元素重复以上的步骤，除了最后一个。</p>

<p>4 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</p>

<ul>
<li>核心代码</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='Java'><span class='line'> <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">arraytoSort</span><span class="o">.</span><span class="na">length</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span><span class="n">i</span><span class="o">++){</span>
</span><span class='line'>        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="n">arraytoSort</span><span class="o">.</span><span class="na">length</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span><span class="n">j</span><span class="o">&gt;=</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span><span class="n">j</span><span class="o">--){</span>
</span><span class='line'>            <span class="kt">int</span> <span class="n">temp</span><span class="o">;</span>
</span><span class='line'>            <span class="k">if</span><span class="o">(</span><span class="n">arraytoSort</span><span class="o">[</span><span class="n">j</span><span class="o">]&lt;</span><span class="n">arraytoSort</span><span class="o">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="o">])</span>
</span><span class='line'>            <span class="o">{</span>
</span><span class='line'>                <span class="n">temp</span> <span class="o">=</span> <span class="n">arraytoSort</span><span class="o">[</span><span class="n">j</span><span class="o">];</span>
</span><span class='line'>                <span class="n">arraytoSort</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">arraytoSort</span><span class="o">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="o">];</span>
</span><span class='line'>                <span class="n">arraytoSort</span><span class="o">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">temp</span><span class="o">;</span>
</span><span class='line'>            <span class="o">}</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<ul>
<li>延伸</li>
</ul>


<p>冒泡排序缺陷：</p>

<ul>
<li><p>某一趟遍历如果没有数据交换，则说明已经排好序了，因此不用再进行迭代了。用一个标记记录这个状态即可。设置一个flag位, 如果一趟无元素交换，则 flag = 0; 以后再也不进入第二层循环。</p></li>
<li><p>当排序的数据比较多时排序的时间会明显延长，因为会比较 n*(n-1)/2次。</p></li>
</ul>


<p>Python实现的优化方案： <a href="https://github.com/wuchong/Algorithm-Interview/blob/master/Sort/python/BubbleSort.py">https://github.com/wuchong/Algorithm-Interview/blob/master/Sort/python/BubbleSort.py</a></p>

<ul>
<li><strong>排序所需的比较次数</strong></li>
</ul>


<p>当n是所需排序的元素个数时，比较排序所需的比较次数按nlog(n)比例增加。</p>

<h3>堆排序</h3>

<h3>快速排序</h3>

<h2>非比较排序算法</h2>

<p><img src="/images/2015-09/non-comparisonSorts.jpg" alt="Non-comparison Sorting" /></p>

<p>非比较排序算法通过非比较操作能在O(n)完成，这使他们能够回避O(nlogn)这个下界（假设元素是定值）。</p>

<h3>桶排序 BucketSort</h3>

<h3>计数排序 CountingSort</h3>

<h3>基数排序 RadixSort</h3>

<h2>stability</h2>

<blockquote><p>A sorting algorithm is stable if whenever there are two records R and S with the same key, and R appears before S in the original list, then R will always appear before S in the sorted list.</p></blockquote>

<p>一个典型的例子就是排序扑克牌，在排序前的扑克序列里，梅花4在红桃4前面，排序后顺序不变。如果是non-stable sort，排序后顺序调换。</p>

<ul>
<li><p>选择排序、快速排序、希尔排序、堆排序不是稳定的排序算法，</p></li>
<li><p>冒泡排序、插入排序、归并排序和基数排序是稳定的排序算法。</p></li>
<li><p>常用时间复杂度的大小关系：</p>

<pre><code>O(1)&lt;O(logn)&lt;O(n)&lt;O(nlogn)&lt;O(n2)&lt;O(n3)&lt;O(2n)&lt;O(n!)&lt;O(nn)
</code></pre></li>
</ul>


<h2>参考链接</h2>

<p><a href="http://segmentfault.com/a/1190000002595152#articleHeader30">http://segmentfault.com/a/1190000002595152#articleHeader30</a></p>

<p><a href="http://wuchong.me/blog/2014/02/09/algorithm-sort-summary/">http://wuchong.me/blog/2014/02/09/algorithm-sort-summary/</a></p>

<h3>一个展示排序过程的视频：</h3>

<p><a href="http://v.youku.com/v_show/id_XNTkwNzI5OTIw.html">http://v.youku.com/v_show/id_XNTkwNzI5OTIw.html</a></p>

<h3>一个展示排序网站：</h3>

<p><a href="http://www.sorting-algorithms.com/">http://www.sorting-algorithms.com/</a></p>

<p>当你打开先点击网页上方的Problem Size，选择一个尺寸，20，30，40还是50，于是你就可以看到下面整个大表中有图片显示出来了。如下所示：</p>

<p><img src="/images/2015-09/sort.jpg" title="排序示例" alt="Sorting" /></p>

<p>其中，</p>

<ul>
<li><p><strong>列。</strong>是代表每一个排序算法，有“插入”“选择”“冒泡”“Shell”，“合并Merge”，“堆排序”，“快速排序”，“快速3排序”。单击每个一算法的链接，你可以看到这个算法的详细解释，其中包括，算法的伪代码，算法的复杂度，相关的讨论，重点，以及该算法的相关参考文档。</p></li>
<li><p><strong>行。</strong>是不同的数据样本，第一个是“随机样本”，第二个是“几乎排好序的样本”，第三个是“最差的样本（反序）”，第四个是“有一些相同项的样本”。这些样本在不同的算法上都会有不同的表现。</p></li>
<li><p><strong>单元格。</strong>每个单元格都是一个图片。简单的用鼠标单击一下每个图片，可以动画地演示算法整个过程。其中两个小红箭头表示了正在需要“交换顺序的数据”。</p></li>
</ul>

</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/posts/2">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
    <h1>About Me</h1>
      <p>互联网打杂的<br/>
      <br/>曾混迹于五道口,
      <br/>慕尼黑工大TUM计算机Master在读。
      <br/>作为一个有人文情怀的理科男，
      <br/>怀有着一腔热情。
      <br/>
      <br />我的<strong>微信名片</strong>
      <br/><img width="220px" src="/images/weixinQR.png" />
      </p>
</section>
<section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2015/09/02/chang-jian-sortingsuan-fa-zong-jie/">常见排序算法总结</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/09/01/hashmapshi-li-:qiu-top-k/">[转]HashMap实例：求Top K</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/08/28/hashmapde-yuan-li-zong-jie/">HashMap的原理总结</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/11/28/first-blog/">How to Use Markdown</a>
      </li>
    
  </ul>
</section>
<section>
    <h1>Categories</h1>
      <ul id="categories">
          <li class='category'><a href='/blog/categories/blog/'>blog (1)</a></li>
<li class='category'><a href='/blog/categories/hashmap/'>hashmap (2)</a></li>
<li class='category'><a href='/blog/categories/markdown/'>markdown (1)</a></li>
<li class='category'><a href='/blog/categories/sorting-/'>sorting, (1)</a></li>
<li class='category'><a href='/blog/categories/topk/'>topk (1)</a></li>
<li class='category'><a href='/blog/categories/数据结构/'>数据结构 (1)</a></li>
<li class='category'><a href='/blog/categories/算法/'>算法 (2)</a></li>

      </ul>
</section>

<section>
  <h1>GitHub Repos</h1>
  <ul id="gh_repos">
    <li class="loading">Status updating&#8230;</li>
  </ul>
  
  <a href="https://github.com/shidh">@shidh</a> on GitHub
  
  <script type="text/javascript">
    $(document).ready(function(){
        if (!window.jXHR){
            var jxhr = document.createElement('script');
            jxhr.type = 'text/javascript';
            jxhr.src = '/javascripts/libs/jXHR.js';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(jxhr, s);
        }

        github.showRepos({
            user: 'shidh',
            count: 3,
            skip_forks: true,
            target: '#gh_repos'
        });
    });
  </script>
  <script src="/javascripts/github.js" type="text/javascript"> </script>
</section>



<section class="googleplus">
  <h1>
    <a href="https://plus.google.com/100494457180372568732?rel=author">
      <img src="http://www.google.com/images/icons/ui/gprofile_button-32.png" width="32" height="32">
      Google+
    </a>
  </h1>
</section>



  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2015 - Allen Shi
  <!--<span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>&#8211;>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'disqus_wj6CMLpme6';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>



<div id="fb-root"></div>
<script>(function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0];
  if (d.getElementById(id)) {return;}
  js = d.createElement(s); js.id = id; js.async = true;
  js.src = "//connect.facebook.net/en_US/all.js#appId=212934732101925&xfbml=1";
  fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));</script>



  <script type="text/javascript">
    (function() {
      var script = document.createElement('script'); script.type = 'text/javascript'; script.async = true;
      script.src = 'https://apis.google.com/js/plusone.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(script, s);
    })();
  </script>







</body>
</html>
